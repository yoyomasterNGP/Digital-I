/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
 module divFreqLCD #(
  parameter integer FREQ_IN = 25000000,
  parameter integer FREQ_OUT = 8000000,
  parameter integer INIT = 0
) (
    input CLK_IN,
    output reg CLK_OUT = 0
);

  localparam integer COUNT = (FREQ_IN / FREQ_OUT) / 2;
  localparam integer SIZE = $clog2(COUNT);
  localparam integer LIMIT = COUNT - 1;

  reg [SIZE-1:0] count = INIT;

  always @(posedge CLK_IN) begin
    if (count == LIMIT) begin
      count   <= 0;
      CLK_OUT <= ~CLK_OUT;
    end else begin
      count <= count + 1;
    end
  end
endmodule


module FrecAntirebote #(
  parameter integer FREQ_IN = 25000000,
  parameter integer FREQ_OUT = 100,
  parameter integer INIT = 0
) (
    // Inputs and output ports
    input CLK_IN,
    output reg CLK_OUT = 0
);

  localparam integer COUNT = (FREQ_IN / FREQ_OUT) / 2;
  localparam integer SIZE = $clog2(COUNT);
  localparam integer LIMIT = COUNT - 1;

  // Declaración de señales [reg, wire]
  reg [SIZE-1:0] count = INIT;

  // Descripción del comportamiento
  always @(posedge CLK_IN) begin
    if (count == LIMIT) begin
      count   <= 0;
      CLK_OUT <= ~CLK_OUT;
    end else begin
      count <= count + 1;
    end
  end
endmodule

module antirebote #(
    parameter DEBOUNCE_TIME = 5 // Tiempo de antirebote en ciclos de clk_rebote (0.2 segundos)
) (
    input clk,          // Reloj de 0.2 segundos (clk_rebote)
    input button_in,    // Entrada del pulsador (con rebotes)
    output reg button_out // Salida del pulsador (sin rebotes)
);

    reg [2:0] count = 0; // Contador para el tiempo de antirebote
    reg button_state = 0; // Estado estable del pulsador

    always @(posedge clk) begin
        if (button_in != button_state) begin
            // Si el estado del pulsador cambia, reinicia el contador
            count <= 0;
            button_state <= button_in;
        end else if (count < DEBOUNCE_TIME) begin
            // Si el estado es estable, incrementa el contador
            count <= count + 1;
        end else begin
            // Si el contador alcanza el tiempo de antirebote, actualiza la salida
            button_out <= button_state;
        end
    end
endmodule




module divFreq #(
  parameter integer FREQ_IN = 25000000,
  parameter integer FREQ_OUT = 1,
  parameter integer INIT = 0
) (
    // Inputs and output ports
    input CLK_IN,
    output reg CLK_OUT = 0
);

  localparam integer COUNT = (FREQ_IN / FREQ_OUT) / 2;
  localparam integer SIZE = $clog2(COUNT);
  localparam integer LIMIT = COUNT - 1;

  // Declaración de señales [reg, wire]
  reg [SIZE-1:0] count = INIT;

  // Descripción del comportamiento
  always @(posedge CLK_IN) begin
    if (count == LIMIT) begin
      count   <= 0;
      CLK_OUT <= ~CLK_OUT;
    end else begin
      count <= count + 1;
    end
  end
endmodule


module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end

endmodule


module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module div (
    input [5:0] NUM,   // Número binario de 6 bits (0 a 63)
    output reg A0, // Bit más significativo del primer dígito (decenas)
    output reg B0, // Bit 2 del primer dígito
    output reg C0, // Bit 1 del primer dígito
    output reg D0, // Bit menos significativo del primer dígito (decenas)
    output reg A1, // Bit más significativo del segundo dígito (unidades)
    output reg B1, // Bit 2 del segundo dígito
    output reg C1, // Bit 1 del segundo dígito
    output reg D1  // Bit menos significativo del segundo dígito (unidades)
);
    integer i;
    reg [5:0] temp;
    reg [3:0] dec_tens;
    reg [3:0] dec_ones;
   
    always @(*) begin
        temp = NUM;
        dec_tens = 4'b0000;
        dec_ones = 4'b0000;
       
        // Restar 10 hasta que el número sea menor que 10
        for (i = 0; i < 6; i = i + 1) begin
            if (temp >= 10) begin
                temp = temp - 10;
                dec_tens = dec_tens + 4'b0001;
            end
        end
       
        // Lo que queda es el dígito de unidades
        dec_ones = temp[3:0];
       
        // Asignar los bits individuales a las salidas con la nomenclatura solicitada
       
        {A0, B0, C0, D0} = dec_tens;
        {A1, B1, C1, D1} = dec_ones;
    end
endmodule



module Contador (
  input clk_count,
  input \++ ,
  input \+ ,
  input \- ,
  input \-_- ,
  output [5:0] Num
);
  wire M;
  wire [5:0] s0;
  wire [5:0] s1;
  wire [5:0] s2;
  wire L;
  wire s3;
  wire [5:0] s4;
  wire s5;
  wire [5:0] s6;
  wire [5:0] s7;
  wire [5:0] Num_temp;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire [6:0] s16;
  wire [6:0] s17;
  assign s3 = (\++  & clk_count);
  assign s5 = (\-_-  & clk_count);
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i0 (
    .en( M ),
    .C( \-  ),
    .clr( 1'b0 ),
    .out( s0 )
  );
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i1 (
    .en( L ),
    .C( \+  ),
    .clr( 1'b0 ),
    .out( s1 )
  );
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i2 (
    .en( L ),
    .C( s3 ),
    .clr( 1'b0 ),
    .out( s4 )
  );
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i3 (
    .en( M ),
    .C( s5 ),
    .clr( 1'b0 ),
    .out( s6 )
  );
  DIG_Sub #(
    .Bits(6)
  )
  DIG_Sub_i4 (
    .a( s1 ),
    .b( s0 ),
    .c_i( 1'b0 ),
    .s( s2 )
  );
  DIG_Sub #(
    .Bits(6)
  )
  DIG_Sub_i5 (
    .a( s4 ),
    .b( s6 ),
    .c_i( 1'b0 ),
    .s( s7 )
  );
  DIG_Add #(
    .Bits(6)
  )
  DIG_Add_i6 (
    .a( s7 ),
    .b( s2 ),
    .c_i( 1'b0 ),
    .s( Num_temp )
  );
  assign L = ~ ((Num_temp[0] & 1'b1) & (Num_temp[1] & 1'b1) & (Num_temp[2] & 1'b1) & (Num_temp[3] & 1'b1) & (Num_temp[4] & 1'b1) & (Num_temp[5] & 1'b1));
  assign M = ((Num_temp[0] | 1'b0) | (Num_temp[1] | 1'b0) | (Num_temp[2] | 1'b0) | (Num_temp[3] | 1'b0) | (Num_temp[4] | 1'b0) | (Num_temp[5] | 1'b0));
  div div_i7 (
    .NUM( Num_temp ),
    .A0( s8 ),
    .B0( s9 ),
    .C0( s10 ),
    .D0( s11 ),
    .A1( s12 ),
    .B1( s13 ),
    .C1( s14 ),
    .D1( s15 )
  );
  assign Num = Num_temp;
endmodule

module \10_2  (
  input clk_FSM,
  output \10-2
);
  wire S;
  wire [3:0] s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  DIG_Counter_Nbit #(
    .Bits(4)
  )
  DIG_Counter_Nbit_i0 (
    .en( 1'b1 ),
    .C( clk_FSM ),
    .clr( S ),
    .out( s0 )
  );
  assign S = ((s1 & 1'b1) & (s2 & 1'b1) & ~ (s3 | 1'b0) & (s4 & 1'b1));
  assign \10-2  = ((~ (s1 | 1'b0) & ~ (s2 | 1'b0) & ~ (s3 | 1'b0) & ~ (s4 | 1'b0)) | (~ (s1 | 1'b0) & (s2 & 1'b1) & ~ (s3 | 1'b0) & (s4 & 1'b1)));
  assign s1 = s0[0];
  assign s2 = s0[1];
  assign s3 = s0[2];
  assign s4 = s0[3];
endmodule

module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Demux1
#(
    parameter Default = 0
)
(
    output out_0,
    output out_1,
    input [0:0] sel,
    input in
);
    assign out_0 = (sel == 1'h0)? in : Default;
    assign out_1 = (sel == 1'h1)? in : Default;
endmodule


module Comparador (
  input [5:0] NA,
  input [5:0] NB,
  input [5:0] NC,
  input [5:0] ND,
  output TA,
  output TB,
  output TC,
  output TD
);
  wire s0;
  wire s1;
  wire [5:0] s2;
  wire [5:0] s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( NA ),
    .b( NB ),
    .\< ( s0 )
  );
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( NC ),
    .b( ND ),
    .\< ( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(6)
  )
  Mux_2x1_NBits_i2 (
    .sel( s0 ),
    .in_0( NA ),
    .in_1( NB ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(6)
  )
  Mux_2x1_NBits_i3 (
    .sel( s1 ),
    .in_0( NC ),
    .in_1( ND ),
    .out( s3 )
  );
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i4 (
    .a( s2 ),
    .b( s3 ),
    .\> ( s4 ),
    .\= ( s5 ),
    .\< ( s6 )
  );
  assign s7 = (s4 | s5);
  assign s9 = (s6 & s1);
  assign s8 = (s0 & s7);
  Demux1 #(
    .Default(0)
  )
  Demux1_i5 (
    .sel( s9 ),
    .in( s6 ),
    .out_0( TC ),
    .out_1( TD )
  );
  Demux1 #(
    .Default(0)
  )
  Demux1_i6 (
    .sel( s8 ),
    .in( s7 ),
    .out_0( TA ),
    .out_1( TB )
  );
endmodule

module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module DIG_JK_FF
#(
    parameter Default = 1'b0
)
(
   input J,
   input C,
   input K,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        if (~J & K)
            state <= 1'b0;
         else if (J & ~K)
            state <= 1'b1;
         else if (J & K)
            state <= ~state;
    end

    initial begin
        state = Default;
    end
endmodule


module FSM (
  input clk_FF,
  input TA,
  input TB,
  input TC,
  input TD,
  output Q0,
  output Q1,
  output Q2,
  output Q3,
  output NQ0,
  output NQ1,
  output NQ2,
  output NQ3
);
  wire s0;
  wire Q0_temp;
  wire NQ0_temp;
  wire s1;
  wire Q3_temp;
  wire NQ3_temp;
  wire s2;
  wire s3;
  wire Q1_temp;
  wire NQ1_temp;
  wire s4;
  wire s5;
  wire Q2_temp;
  wire NQ2_temp;
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( s0 ),
    .C( clk_FF ),
    .Q( Q0_temp ),
    .\~Q ( NQ0_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( s1 ),
    .C( clk_FF ),
    .Q( Q3_temp ),
    .\~Q ( NQ3_temp )
  );
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i2 (
    .J( s2 ),
    .C( clk_FF ),
    .K( s3 ),
    .Q( Q1_temp ),
    .\~Q ( NQ1_temp )
  );
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i3 (
    .J( s4 ),
    .C( clk_FF ),
    .K( s5 ),
    .Q( Q2_temp ),
    .\~Q ( NQ2_temp )
  );
  assign s0 = (((TC | TD) & NQ0_temp & NQ1_temp & NQ2_temp & NQ3_temp) | (TA & ((NQ3_temp & NQ2_temp & Q1_temp & NQ0_temp) | (NQ3_temp & Q2_temp & Q1_temp & NQ0_temp))));
  assign s2 = ((TC & ((Q3_temp & Q2_temp & NQ1_temp & NQ0_temp) | (Q3_temp & NQ2_temp & NQ1_temp & Q0_temp))) | (TD & ((NQ3_temp & Q2_temp & NQ1_temp & NQ0_temp) | (NQ3_temp & NQ2_temp & NQ1_temp & Q0_temp))));
  assign s3 = ((NQ3_temp & NQ2_temp & Q1_temp & NQ0_temp & (TA | TB)) | (TA & NQ3_temp & Q2_temp & Q1_temp & NQ0_temp) | (TB & Q3_temp & Q2_temp & Q1_temp & NQ0_temp));
  assign s4 = ((TD & ((Q3_temp & NQ2_temp & Q1_temp & NQ0_temp) | (NQ3_temp & NQ2_temp & NQ1_temp & Q0_temp))) | (TB & ((NQ3_temp & NQ2_temp & Q1_temp & NQ0_temp) | (Q3_temp & NQ2_temp & NQ1_temp & NQ0_temp))));
  assign s5 = ((NQ3_temp & Q2_temp & Q1_temp & NQ0_temp & (TA | TC)) | (TA & NQ3_temp & Q2_temp & NQ1_temp & NQ0_temp) | (TC & Q3_temp & Q2_temp & NQ1_temp & NQ0_temp));
  assign s1 = (((TB | TC) & NQ3_temp & NQ2_temp & NQ1_temp & NQ0_temp) | ((TA | TC | TD) & NQ3_temp & Q2_temp & NQ1_temp & NQ0_temp) | ((TB | TC) & NQ3_temp & Q2_temp & Q1_temp & NQ0_temp) | ((TA | TB | TD) & NQ3_temp & NQ2_temp & Q1_temp & NQ0_temp));
  assign Q0 = Q0_temp;
  assign Q1 = Q1_temp;
  assign Q2 = Q2_temp;
  assign Q3 = Q3_temp;
  assign NQ0 = NQ0_temp;
  assign NQ1 = NQ1_temp;
  assign NQ2 = NQ2_temp;
  assign NQ3 = NQ3_temp;
endmodule

module Semaforo_A (
  input Q0,
  input Q1,
  input Q2,
  input Q3,
  input NQ0,
  input NQ1,
  input NQ2,
  input NQ3,
  output RA,
  output AA,
  output VA
);
  assign RA = (Q1 | Q2);
  assign AA = (Q0 | (NQ1 & NQ2 & Q3));
  assign VA = (NQ3 & NQ2 & NQ1 & NQ0);
endmodule

module Semaforo_B (
  input Q0,
  input Q1,
  input Q2,
  input Q3,
  input NQ0,
  input NQ1,
  input NQ2,
  input NQ3,
  output RB,
  output AB,
  output VB
);
  assign RB = ((NQ3 & Q2 & Q1) | Q0 | (NQ2 & NQ3) | (NQ2 & Q1));
  assign AB = ((Q2 & Q3) | (Q3 & NQ0 & NQ1));
  assign VB = (Q2 & NQ3 & NQ1);
endmodule

module Semaforo_C (
  input Q0,
  input Q1,
  input Q2,
  input Q3,
  input NQ0,
  input NQ1,
  input NQ2,
  input NQ3,
  output RC,
  output AC,
  output VC
);
  assign VC = (NQ2 & NQ3 & Q1);
  assign AC = ((Q2 & Q3 & NQ1) | (Q3 & NQ2 & Q0) | (Q3 & NQ2 & Q1));
  assign RC = ((NQ2 & NQ1 & NQ0) | (NQ3 & Q2) | (Q1 & Q2) | (NQ3 & NQ1 & Q0));
endmodule

module Semaforo_D (
  input Q0,
  input Q1,
  input Q2,
  input Q3,
  input NQ0,
  input NQ1,
  input NQ2,
  input NQ3,
  output RD,
  output AD,
  output VD
);
  assign RD = ((NQ1 & Q3) | (NQ3 & NQ2 & NQ0) | (NQ0 & NQ1));
  assign AD = ((Q0 & NQ2 & NQ3) | (Q3 & Q1));
  assign VD = (Q2 & NQ3 & Q1);
endmodule

module top (
    input hclk, // Reloj de 25 MHz
    input App, input Ap, input Al, input All,
    input Bpp, input Bp, input Bl, input Bll,
    input Cpp, input Cp, input Cl, input Cll,
    input Dpp, input Dp, input Dl, input Dll,
    output RB, output AB, output VB,
    output RA, output AA, output VA,
    output RD, output AD, output VD,
    output RC, output AC, output VC,
    output RS, RW, E,
    output D0, D1, D2, D3, D4, D5, D6, D7
);

    // Señales debounced
    wire App_debounced, Ap_debounced, Al_debounced, All_debounced;
    wire Bpp_debounced, Bp_debounced, Bl_debounced, Bll_debounced;
    wire Cpp_debounced, Cp_debounced, Cl_debounced, Cll_debounced;
    wire Dpp_debounced, Dp_debounced, Dl_debounced, Dll_debounced;

    // Divisor de frecuencia para el antirebote (0.2 segundos)
    wire clk_rebote;
    FrecAntirebote clk3 (
        .CLK_IN(hclk),
        .CLK_OUT(clk_rebote)
    );

    // Instancias del antirebote para cada pulsador
    antirebote debounce_App (.clk(clk_rebote), .button_in(App), .button_out(App_debounced));
    antirebote debounce_Ap  (.clk(clk_rebote), .button_in(Ap),  .button_out(Ap_debounced));
    antirebote debounce_Al  (.clk(clk_rebote), .button_in(Al),  .button_out(Al_debounced));
    antirebote debounce_All (.clk(clk_rebote), .button_in(All), .button_out(All_debounced));

    antirebote debounce_Bpp (.clk(clk_rebote), .button_in(Bpp), .button_out(Bpp_debounced));
    antirebote debounce_Bp  (.clk(clk_rebote), .button_in(Bp),  .button_out(Bp_debounced));
    antirebote debounce_Bl  (.clk(clk_rebote), .button_in(Bl),  .button_out(Bl_debounced));
    antirebote debounce_Bll (.clk(clk_rebote), .button_in(Bll), .button_out(Bll_debounced));

    antirebote debounce_Cpp (.clk(clk_rebote), .button_in(Cpp), .button_out(Cpp_debounced));
    antirebote debounce_Cp  (.clk(clk_rebote), .button_in(Cp),  .button_out(Cp_debounced));
    antirebote debounce_Cl  (.clk(clk_rebote), .button_in(Cl),  .button_out(Cl_debounced));
    antirebote debounce_Cll (.clk(clk_rebote), .button_in(Cll), .button_out(Cll_debounced));

    antirebote debounce_Dpp (.clk(clk_rebote), .button_in(Dpp), .button_out(Dpp_debounced));
    antirebote debounce_Dp  (.clk(clk_rebote), .button_in(Dp),  .button_out(Dp_debounced));
    antirebote debounce_Dl  (.clk(clk_rebote), .button_in(Dl),  .button_out(Dl_debounced));
    antirebote debounce_Dll (.clk(clk_rebote), .button_in(Dll), .button_out(Dll_debounced));

    // Resto del código original
    wire [5:0] NA;
    wire [5:0] ND;
    wire [5:0] NB;
    wire [5:0] NC;
    wire s0;
    wire s1;
    wire s2;
    wire s3;
    wire s4;
    wire Q0;
    wire Q1;
    wire Q2;
    wire Q3;
    wire NQ0;
    wire NQ1;
    wire NQ2;
    wire NQ3;

    wire clk_count;
    divFreq clk1(
        .CLK_IN(hclk),
        .CLK_OUT(clk_count)
    );

    Contador Contador_i0 (
        .clk_count(clk_count),
        .\++ (App_debounced),
        .\+ (Ap_debounced),
        .\- (Al_debounced),
        .\-_- (All_debounced),
        .Num(NA)
    );

    Contador Contador_i1 (
        .clk_count(clk_count),
        .\++ (Dpp_debounced),
        .\+ (Dp_debounced),
        .\- (Dl_debounced),
        .\-_- (Dll_debounced),
        .Num(ND)
    );

    Contador Contador_i2 (
        .clk_count(clk_count),
        .\++ (Bpp_debounced),
        .\+ (Bp_debounced),
        .\- (Bl_debounced),
        .\-_- (Bll_debounced),
        .Num(NB)
    );

    Contador Contador_i3 (
        .clk_count(clk_count),
        .\++ (Cpp_debounced),
        .\+ (Cp_debounced),
        .\- (Cl_debounced),
        .\-_- (Cll_debounced),
        .Num(NC)
    );

    \10_2  \10_2_i4 (
        .clk_FSM(clk_count),
        .\10-2 (s4)
    );

    Comparador Comparador_i5 (
        .NA(NA),
        .NB(NB),
        .NC(NC),
        .ND(ND),
        .TA(s0),
        .TB(s1),
        .TC(s2),
        .TD(s3)
    );

    FSM FSM_i7 (
        .clk_FF(s4),
        .TA(s0),
        .TB(s1),
        .TC(s2),
        .TD(s3),
        .Q0(Q0),
        .Q1(Q1),
        .Q2(Q2),
        .Q3(Q3),
        .NQ0(NQ0),
        .NQ1(NQ1),
        .NQ2(NQ2),
        .NQ3(NQ3)
    );

    Semaforo_A Semaforo_A_i8 (
        .Q0(Q0),
        .Q1(Q1),
        .Q2(Q2),
        .Q3(Q3),
        .NQ0(NQ0),
        .NQ1(NQ1),
        .NQ2(NQ2),
        .NQ3(NQ3),
        .RA(RA),
        .AA(AA),
        .VA(VA)
    );

    Semaforo_B Semaforo_B_i9 (
        .Q0(Q0),
        .Q1(Q1),
        .Q2(Q2),
        .Q3(Q3),
        .NQ0(NQ0),
        .NQ1(NQ1),
        .NQ2(NQ2),
        .NQ3(NQ3),
        .RB(RB),
        .AB(AB),
        .VB(VB)
    );

    Semaforo_C Semaforo_C_i10 (
        .Q0(Q0),
        .Q1(Q1),
        .Q2(Q2),
        .Q3(Q3),
        .NQ0(NQ0),
        .NQ1(NQ1),
        .NQ2(NQ2),
        .NQ3(NQ3),
        .RC(RC),
        .AC(AC),
        .VC(VC)
    );

    Semaforo_D Semaforo_D_i11 (
        .Q0(Q0),
        .Q1(Q1),
        .Q2(Q2),
        .Q3(Q3),
        .NQ0(NQ0),
        .NQ1(NQ1),
        .NQ2(NQ2),
        .NQ3(NQ3),
        .RD(RD),
        .AD(AD),
        .VD(VD)
    );

    // Conexión al módulo LCD
    wire [7:0] dat;

  
   // Contador para lcd
 divFreqLCD clk2 (
        .CLK_IN(hclk),
        .CLK_OUT(clk_count_lcd)
    );

// Obtención de cada digito
   wire AA0, AB0, AC0, AD0;
   wire AA1, AB1, AC1, AD1;
   wire BA0, BB0, BC0, BD0;
   wire BA1, BB1, BC1, BD1;
   wire CA0, CB0, CC0, CD0;
   wire CA1, CB1, CC1, CD1;
   wire DA0, DB0, DC0, DD0;
   wire DA1, DB1, DC1, DD1;

 div divA (
    .NUM( NA ),
    .A0( AA0 ),
    .B0( AB0 ),
    .C0( AC0 ),
    .D0( AD0 ),
    .A1( AA1 ),
    .B1( AB1 ),
    .C1( AC1 ),
    .D1( AD1 )
  );

 div divB (
    .NUM( NB ),
    .A0( BA0 ),
    .B0( BB0 ),
    .C0( BC0 ),
    .D0( BD0 ),
    .A1( BA1 ),
    .B1( BB1 ),
    .C1( BC1 ),
    .D1( BD1 )
  );

 div divC (
    .NUM( NC ),
    .A0( CA0 ),
    .B0( CB0 ),
    .C0( CC0 ),
    .D0( CD0 ),
    .A1( CA1 ),
    .B1( CB1 ),
    .C1( CC1 ),
    .D1( CD1 )
  );

 div divD (
    .NUM( ND ),
    .A0( DA0 ),
    .B0( DB0 ),
    .C0( DC0 ),
    .D0( DD0 ),
    .A1( DA1 ),
    .B1( DB1 ),
    .C1( DC1 ),
    .D1( DD1 )
  );

wire [3:0] ADp;  // Vector de 4 bits
wire [3:0] AUp;  // Vector de 4 bits
wire [3:0] BDp;  // Vector de 4 bits
wire [3:0] BUp;  // Vector de 4 bits
wire [3:0] CDp;  // Vector de 4 bits
wire [3:0] CUp;  // Vector de 4 bits
wire [3:0] DDp;  // Vector de 4 bits
wire [3:0] DUp;  // Vector de 4 bits

assign ADp = {AA0, AB0, AC0, AD0};
assign AUp = {AA1, AB1, AC1, AD1};

assign BDp = {BA0, BB0, BC0, BD0};
assign BUp = {BA1, BB1, BC1, BD1};

assign CDp = {CA0, CB0, CC0, CD0};
assign CUp = {CA1, CB1, CC1, CD1};

assign DDp = {DA0, DB0, DC0, DD0};
assign DUp = {DA1, DB1, DC1, DD1};

// Instancia del módulo LCD
   LCD lcd_inst (
    .clk(clk_count_lcd),
    .rs(RS),
    .en(E),
    .rw(RW),
    .dat(dat),
    .AD(ADp),
    .AU(AUp),
    .BD(BDp),
    .BU(BUp),
    .CD(CDp),
    .CU(CUp),
    .DD(DDp),
    .DU(DUp)
);
    assign D0 = dat[0];
    assign D1 = dat[1];
    assign D2 = dat[2];
    assign D3 = dat[3];
    assign D4 = dat[4];
    assign D5 = dat[5];
    assign D6 = dat[6];
    assign D7 = dat[7];

endmodule

module LCD(
    input clk,
    output reg rs,
    output reg en,
    output reg rw,
    output reg [7:0] dat,
    input [3:0] AD, //4 Bits decenas de A
    input [3:0] AU, //4 Bits Unidades de A
    input [3:0] BD, //4 Bits decenas de B
    input [3:0] BU, //4 Bits Unidades de B
    input [3:0] CD, //4 Bits decenas de C
    input [3:0] CU, //4 Bits Unidades de C
    input [3:0] DD, //4 Bits decenas de D
    input [3:0] DU //4 Bits Unidades de D
);

    reg [15:0] counter;
    reg [5:0] current, next;
    reg clkR;

    // Registros para almacenar los valores ASCII
    reg [7:0] A1_ascii, A0_ascii, B1_ascii, B0_ascii, C1_ascii, C0_ascii, D1_ascii, D0_ascii;

    // Función para convertir binario a ASCII
    function [7:0] bin_to_ascii;
        input [3:0] bin;
        begin
            if (bin <= 4'b1001) // 0-9
                bin_to_ascii = 8'h30 + bin;
            else // A-F
                bin_to_ascii = 8'h41 + (bin - 4'b1010);
        end
    endfunction

    initial begin
        dat = 0;
        rs = 0;
        counter = 0;
        current = 0;
        next = 0;
        clkR = 0;
    end

    always @(posedge clk) begin
        counter = counter + 1;
        if (counter == 16'hFFFF) clkR = ~clkR;
    end

    always @(posedge clkR) begin
        // Convertir los valores binarios a ASCII
        A1_ascii = bin_to_ascii({3'b000, AD});
        A0_ascii = bin_to_ascii({3'b000, AU});
        B1_ascii = bin_to_ascii({3'b000, BD});
        B0_ascii = bin_to_ascii({3'b000, BU});
        C1_ascii = bin_to_ascii({3'b000, CD});
        C0_ascii = bin_to_ascii({3'b000, CU});
        D1_ascii = bin_to_ascii({3'b000, DD});
        D0_ascii = bin_to_ascii({3'b000, DU});

        current = next;
        case (current)
            0:  begin rs <= 0; dat <= 8'h38; next <= 1; end // Config 8bit
            1:  begin rs <= 0; dat <= 8'h38; next <= 2; end 
            2:  begin rs <= 0; dat <= 8'h0E; next <= 4; end 
            3:  begin rs <= 0; dat <= 8'h01; next <= 4; end 
            
            // Fila 1
            4:  begin rs <= 0; dat <= 8'h80; next <= 5; end
            5:  begin rs <= 1; dat <= 8'h53; next <= 6; end // S
            6:  begin rs <= 1; dat <= 8'h6D; next <= 7; end // m
            7:  begin rs <= 1; dat <= 8'h66; next <= 8; end // f
            8:  begin rs <= 1; dat <= 8'h41; next <= 9; end // A
            9:  begin rs <= 1; dat <= 8'h3A; next <= 10; end // :
            10: begin rs <= 1; dat <= A1_ascii; next <= 11; end // A1 en hexadecimal
            11: begin rs <= 1; dat <= A0_ascii; next <= 12; end // A0 en hexadecimal
            12: begin rs <= 1; dat <= 8'h20; next <= 13; end // Espacio
            13: begin rs <= 1; dat <= 8'h53; next <= 14; end // S
            14: begin rs <= 1; dat <= 8'h6D; next <= 15; end // m
            15: begin rs <= 1; dat <= 8'h66; next <= 16; end // f
            16: begin rs <= 1; dat <= 8'h42; next <= 17; end // B
            17: begin rs <= 1; dat <= 8'h3A; next <= 18; end // :
            18: begin rs <= 1; dat <= B1_ascii; next <= 19; end // B1 en hexadecimal
            19: begin rs <= 1; dat <= B0_ascii; next <= 20; end // B0 en hexadecimal
            
            // Fila 2
            20: begin rs <= 0; dat <= 8'hC0; next <= 21; end
            21: begin rs <= 1; dat <= 8'h53; next <= 22; end // S
            22: begin rs <= 1; dat <= 8'h6D; next <= 23; end // m
            23: begin rs <= 1; dat <= 8'h66; next <= 24; end // f
            24: begin rs <= 1; dat <= 8'h43; next <= 25; end // C
            25: begin rs <= 1; dat <= 8'h3A; next <= 26; end // :
            26: begin rs <= 1; dat <= C1_ascii; next <= 27; end // C1 en hexadecimal
            27: begin rs <= 1; dat <= C0_ascii; next <= 28; end // C0 en hexadecimal
            28: begin rs <= 1; dat <= 8'h20; next <= 29; end // Espacio
            29: begin rs <= 1; dat <= 8'h53; next <= 30; end // S
            30: begin rs <= 1; dat <= 8'h6D; next <= 31; end // m
            31: begin rs <= 1; dat <= 8'h66; next <= 32; end // f
            32: begin rs <= 1; dat <= 8'h44; next <= 33; end // D
            33: begin rs <= 1; dat <= 8'h3A; next <= 34; end // :
            34: begin rs <= 1; dat <= D1_ascii; next <= 35; end // D1 en hexadecimal
            35: begin rs <= 1; dat <= D0_ascii; next <= 0; end // D0 en hexadecimal
            default: next = 0;
        endcase
    end

    assign en = clkR;
    assign rw = 0;
endmodule

