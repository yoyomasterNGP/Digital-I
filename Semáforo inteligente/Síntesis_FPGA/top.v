/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module divFreq #(
  parameter integer FREQ_IN = 25000000,
  parameter integer FREQ_OUT = 1,
  parameter integer INIT = 0
) (
    // Inputs and output ports
    input CLK_IN,
    output reg CLK_OUT = 0
);

  localparam integer COUNT = (FREQ_IN / FREQ_OUT) / 2;
  localparam integer SIZE = $clog2(COUNT);
  localparam integer LIMIT = COUNT - 1;

  // Declaración de señales [reg, wire]
  reg [SIZE-1:0] count = INIT;

  // Descripción del comportamiento
  always @(posedge CLK_IN) begin
    if (count == LIMIT) begin
      count   <= 0;
      CLK_OUT <= ~CLK_OUT;
    end else begin
      count <= count + 1;
    end
  end
endmodule

module divFreqMUX #(
  parameter integer FREQ_IN = 25000000,
  parameter integer FREQ_OUT = 1000,
  parameter integer INIT = 0
) (
    // Inputs and output ports
    input CLK_IN,
    output reg CLK_OUT = 0
);

  localparam integer COUNT = (FREQ_IN / FREQ_OUT) / 2;
  localparam integer SIZE = $clog2(COUNT);
  localparam integer LIMIT = COUNT - 1;

  // Declaración de señales [reg, wire]
  reg [SIZE-1:0] count = INIT;

  // Descripción del comportamiento
  always @(posedge CLK_IN) begin
    if (count == LIMIT) begin
      count   <= 0;
      CLK_OUT <= ~CLK_OUT;
    end else begin
      count <= count + 1;
    end
  end
endmodule
































module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end

endmodule


module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module div (
    input [5:0] NUM,   // Número binario de 6 bits (0 a 63)
    output reg A0, // Bit más significativo del primer dígito (decenas)
    output reg B0, // Bit 2 del primer dígito
    output reg C0, // Bit 1 del primer dígito
    output reg D0, // Bit menos significativo del primer dígito (decenas)
    output reg A1, // Bit más significativo del segundo dígito (unidades)
    output reg B1, // Bit 2 del segundo dígito
    output reg C1, // Bit 1 del segundo dígito
    output reg D1  // Bit menos significativo del segundo dígito (unidades)
);
    integer i;
    reg [5:0] temp;
    reg [3:0] dec_tens;
    reg [3:0] dec_ones;
    
    always @(*) begin
        temp = NUM;
        dec_tens = 4'b0000;
        dec_ones = 4'b0000;
        
        // Restar 10 hasta que el número sea menor que 10
        for (i = 0; i < 6; i = i + 1) begin
            if (temp >= 10) begin
                temp = temp - 10;
                dec_tens = dec_tens + 4'b0001;
            end
        end
        
        // Lo que queda es el dígito de unidades
        dec_ones = temp[3:0];
        
        // Asignar los bits individuales a las salidas con la nomenclatura solicitada
        {A0, B0, C0, D0} = dec_tens;
        {A1, B1, C1, D1} = dec_ones;
    end
endmodule







module bcd_7S (
  input A,
  input B,
  input C,
  input D,
  output [6:0] \7S 
);
  wire NAP;
  wire NBP;
  wire NCP;
  wire NDP;
  assign NAP = ~ A;
  assign NBP = ~ B;
  assign NCP = ~ C;
  assign NDP = ~ D;
  assign \7S [0] = ((A & NDP) | (B & C) | (A & NBP & NCP) | (NAP & C) | (NAP & B & D) | (NBP & NDP));
  assign \7S [1] = ((NAP & C & D) | (NAP & NDP & NCP) | (NBP & NCP) | (NAP & NBP));
  assign \7S [2] = ((NAP & NCP) | (NAP & D) | (NBP & NCP) | (NAP & B));
  assign \7S [3] = ((NCP & NBP & NDP) | (A & NBP & D) | (B & NCP & D) | (NAP & NBP & C) | (B & C & NDP) | (A & NCP));
  assign \7S [4] = ((NCP & NBP & NDP) | (NAP & C & NDP));
  assign \7S [5] = ((NAP & NCP & NDP) | (NAP & B & NCP) | (NAP & B & NDP) | (A & NBP & NCP));
  assign \7S [6] = ((NAP & NBP & C) | (NAP & NDP & C) | (NAP & B & NCP) | (A & NBP & NCP));
endmodule

module Contador (
  input clk_count,
  input \++ ,
  input \+ ,
  input \- ,
  input \-_- ,
  output [5:0] Num,
  output [13:0] \NUM-7S 
);
  wire M;
  wire [5:0] s0;
  wire [5:0] s1;
  wire [5:0] s2;
  wire L;
  wire s3;
  wire [5:0] s4;
  wire s5;
  wire [5:0] s6;
  wire [5:0] s7;
  wire [5:0] Num_temp;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire [6:0] s16;
  wire [6:0] s17;
  assign s3 = (\++  & clk_count);
  assign s5 = (\-_-  & clk_count);
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i0 (
    .en( M ),
    .C( \-  ),
    .clr( 1'b0 ),
    .out( s0 )
  );
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i1 (
    .en( L ),
    .C( \+  ),
    .clr( 1'b0 ),
    .out( s1 )
  );
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i2 (
    .en( L ),
    .C( s3 ),
    .clr( 1'b0 ),
    .out( s4 )
  );
  DIG_Counter_Nbit #(
    .Bits(6)
  )
  DIG_Counter_Nbit_i3 (
    .en( M ),
    .C( s5 ),
    .clr( 1'b0 ),
    .out( s6 )
  );
  DIG_Sub #(
    .Bits(6)
  )
  DIG_Sub_i4 (
    .a( s1 ),
    .b( s0 ),
    .c_i( 1'b0 ),
    .s( s2 )
  );
  DIG_Sub #(
    .Bits(6)
  )
  DIG_Sub_i5 (
    .a( s4 ),
    .b( s6 ),
    .c_i( 1'b0 ),
    .s( s7 )
  );
  DIG_Add #(
    .Bits(6)
  )
  DIG_Add_i6 (
    .a( s7 ),
    .b( s2 ),
    .c_i( 1'b0 ),
    .s( Num_temp )
  );
  assign L = ~ ((Num_temp[0] & 1'b1) & (Num_temp[1] & 1'b1) & (Num_temp[2] & 1'b1) & (Num_temp[3] & 1'b1) & (Num_temp[4] & 1'b1) & (Num_temp[5] & 1'b1));
  assign M = ((Num_temp[0] | 1'b0) | (Num_temp[1] | 1'b0) | (Num_temp[2] | 1'b0) | (Num_temp[3] | 1'b0) | (Num_temp[4] | 1'b0) | (Num_temp[5] | 1'b0));
  div div_i7 (
    .NUM( Num_temp ),
    .A0( s8 ),
    .B0( s9 ),
    .C0( s10 ),
    .D0( s11 ),
    .A1( s12 ),
    .B1( s13 ),
    .C1( s14 ),
    .D1( s15 )
  );
  bcd_7S bcd_7S_i8 (
    .A( s8 ),
    .B( s9 ),
    .C( s10 ),
    .D( s11 ),
    .\7S ( s16 )
  );
  bcd_7S bcd_7S_i9 (
    .A( s12 ),
    .B( s13 ),
    .C( s14 ),
    .D( s15 ),
    .\7S ( s17 )
  );
  assign \NUM-7S [6:0] = s16;
  assign \NUM-7S [13:7] = s17;
  assign Num = Num_temp;
endmodule

module \10_2  (
  input clk_FSM,
  output \10-2 
);
  wire S;
  wire [3:0] s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  DIG_Counter_Nbit #(
    .Bits(4)
  )
  DIG_Counter_Nbit_i0 (
    .en( 1'b1 ),
    .C( clk_FSM ),
    .clr( S ),
    .out( s0 )
  );
  assign S = ((s1 & 1'b1) & (s2 & 1'b1) & ~ (s3 | 1'b0) & (s4 & 1'b1));
  assign \10-2  = ((~ (s1 | 1'b0) & ~ (s2 | 1'b0) & ~ (s3 | 1'b0) & ~ (s4 | 1'b0)) | (~ (s1 | 1'b0) & (s2 & 1'b1) & ~ (s3 | 1'b0) & (s4 & 1'b1)));
  assign s1 = s0[0];
  assign s2 = s0[1];
  assign s3 = s0[2];
  assign s4 = s0[3];
endmodule

module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Demux1
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    input [0:0] sel,
    input in
);
    assign out_0 = (sel == 1'h0)? in : Default;
    assign out_1 = (sel == 1'h1)? in : Default;
endmodule


module Comparador (
  input [5:0] NA,
  input [5:0] NB,
  input [5:0] NC,
  input [5:0] ND,
  output TA,
  output TB,
  output TC,
  output TD
);
  wire s0;
  wire s1;
  wire [5:0] s2;
  wire [5:0] s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( NA ),
    .b( NB ),
    .\< ( s0 )
  );
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( NC ),
    .b( ND ),
    .\< ( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(6)
  )
  Mux_2x1_NBits_i2 (
    .sel( s0 ),
    .in_0( NA ),
    .in_1( NB ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(6)
  )
  Mux_2x1_NBits_i3 (
    .sel( s1 ),
    .in_0( NC ),
    .in_1( ND ),
    .out( s3 )
  );
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i4 (
    .a( s2 ),
    .b( s3 ),
    .\> ( s4 ),
    .\= ( s5 ),
    .\< ( s6 )
  );
  assign s7 = (s4 | s5);
  assign s9 = (s6 & s1);
  assign s8 = (s0 & s7);
  Demux1 #(
    .Default(0)
  )
  Demux1_i5 (
    .sel( s9 ),
    .in( s6 ),
    .out_0( TC ),
    .out_1( TD )
  );
  Demux1 #(
    .Default(0)
  )
  Demux1_i6 (
    .sel( s8 ),
    .in( s7 ),
    .out_0( TA ),
    .out_1( TB )
  );
endmodule

module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module MUX (
  input clk_MUX,
  input [13:0] \7SA ,
  input [13:0] \7SB ,
  input [13:0] \7SC ,
  input [13:0] \7SD ,
  output a,
  output b,
  output c,
  output d,
  output e,
  output f,
  output g,
  output EA0,
  output EA1,
  output EB0,
  output EB1,
  output EC0,
  output EC1,
  output ED0,
  output ED1
);
  wire [2:0] s0;
  wire [6:0] NA0;
  wire [6:0] NA1;
  wire [6:0] NB0;
  wire [6:0] NB1;
  wire [6:0] NC0;
  wire [6:0] NC1;
  wire [6:0] ND0;
  wire [6:0] ND1;
  wire [6:0] s1;
  wire NX0;
  wire X0;
  wire s2;
  wire X1;
  wire NX1;
  wire s3;
  wire X2;
  wire NX2;
  assign NA0 = \7SA [6:0];
  assign NA1 = \7SA [13:7];
  assign NB0 = \7SB [6:0];
  assign NB1 = \7SB [13:7];
  assign NC0 = \7SC [6:0];
  assign NC1 = \7SC [13:7];
  assign ND0 = \7SD [6:0];
  assign ND1 = \7SD [13:7];
  Mux_8x1_NBits #(
    .Bits(7)
  )
  Mux_8x1_NBits_i0 (
    .sel( s0 ),
    .in_0( NA0 ),
    .in_1( NA1 ),
    .in_2( NB0 ),
    .in_3( NB1 ),
    .in_4( NC0 ),
    .in_5( NC1 ),
    .in_6( ND0 ),
    .in_7( ND1 ),
    .out( s1 )
  );
  assign a = ~ s1[0];
  assign b = ~ s1[1];
  assign c = ~ s1[2];
  assign d = ~ s1[3];
  assign e = ~ s1[4];
  assign f = ~ s1[5];
  assign g = ~ s1[6];
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( NX0 ),
    .C( clk_MUX ),
    .Q( X0 ),
    .\~Q ( NX0 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i2 (
    .D( s2 ),
    .C( clk_MUX ),
    .Q( X1 ),
    .\~Q ( NX1 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i3 (
    .D( s3 ),
    .C( clk_MUX ),
    .Q( X2 ),
    .\~Q ( NX2 )
  );
  assign s2 = (X1 ^ X0);
  assign s3 = ((X2 & NX0) | (X0 & NX2 & X1) | (X2 & NX1));
  assign s0[0] = X0;
  assign s0[1] = X1;
  assign s0[2] = X2;
  assign EA1 = ~ (X2 | X1 | NX0);
  assign EB1 = ~ (X2 | NX1 | NX0);
  assign EC1 = ~ (NX2 | X1 | NX0);
  assign ED1 = ~ (NX2 | NX1 | NX0);
  assign EA0 = ~ (X2 | X1 | X0);
  assign EB0 = ~ (X2 | NX1 | X0);
  assign EC0 = ~ (NX2 | X1 | X0);
  assign ED0 = ~ (NX2 | NX1 | X0);
endmodule
module DIG_JK_FF
#(
    parameter Default = 1'b0
)
(
   input J,
   input C,
   input K,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        if (~J & K)
            state <= 1'b0;
         else if (J & ~K)
            state <= 1'b1;
         else if (J & K)
            state <= ~state;
    end

    initial begin
        state = Default;
    end
endmodule


module FSM (
  input clk_FF,
  input TA,
  input TB,
  input TC,
  input TD,
  output Q0,
  output Q1,
  output Q2,
  output Q3,
  output NQ0,
  output NQ1,
  output NQ2,
  output NQ3
);
  wire s0;
  wire Q0_temp;
  wire NQ0_temp;
  wire s1;
  wire Q3_temp;
  wire NQ3_temp;
  wire s2;
  wire s3;
  wire Q1_temp;
  wire NQ1_temp;
  wire s4;
  wire s5;
  wire Q2_temp;
  wire NQ2_temp;
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( s0 ),
    .C( clk_FF ),
    .Q( Q0_temp ),
    .\~Q ( NQ0_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( s1 ),
    .C( clk_FF ),
    .Q( Q3_temp ),
    .\~Q ( NQ3_temp )
  );
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i2 (
    .J( s2 ),
    .C( clk_FF ),
    .K( s3 ),
    .Q( Q1_temp ),
    .\~Q ( NQ1_temp )
  );
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i3 (
    .J( s4 ),
    .C( clk_FF ),
    .K( s5 ),
    .Q( Q2_temp ),
    .\~Q ( NQ2_temp )
  );
  assign s0 = (((TC | TD) & NQ0_temp & NQ1_temp & NQ2_temp & NQ3_temp) | (TA & ((NQ3_temp & NQ2_temp & Q1_temp & NQ0_temp) | (NQ3_temp & Q2_temp & Q1_temp & NQ0_temp))));
  assign s2 = ((TC & ((Q3_temp & Q2_temp & NQ1_temp & NQ0_temp) | (Q3_temp & NQ2_temp & NQ1_temp & Q0_temp))) | (TD & ((NQ3_temp & Q2_temp & NQ1_temp & NQ0_temp) | (NQ3_temp & NQ2_temp & NQ1_temp & Q0_temp))));
  assign s3 = ((NQ3_temp & NQ2_temp & Q1_temp & NQ0_temp & (TA | TB)) | (TA & NQ3_temp & Q2_temp & Q1_temp & NQ0_temp) | (TB & Q3_temp & Q2_temp & Q1_temp & NQ0_temp));
  assign s4 = ((TD & ((Q3_temp & NQ2_temp & Q1_temp & NQ0_temp) | (NQ3_temp & NQ2_temp & NQ1_temp & Q0_temp))) | (TB & ((NQ3_temp & NQ2_temp & Q1_temp & NQ0_temp) | (Q3_temp & NQ2_temp & NQ1_temp & NQ0_temp))));
  assign s5 = ((NQ3_temp & Q2_temp & Q1_temp & NQ0_temp & (TA | TC)) | (TA & NQ3_temp & Q2_temp & NQ1_temp & NQ0_temp) | (TC & Q3_temp & Q2_temp & NQ1_temp & NQ0_temp));
  assign s1 = (((TB | TC) & NQ3_temp & NQ2_temp & NQ1_temp & NQ0_temp) | ((TA | TC | TD) & NQ3_temp & Q2_temp & NQ1_temp & NQ0_temp) | ((TB | TC) & NQ3_temp & Q2_temp & Q1_temp & NQ0_temp) | ((TA | TB | TD) & NQ3_temp & NQ2_temp & Q1_temp & NQ0_temp));
  assign Q0 = Q0_temp;
  assign Q1 = Q1_temp;
  assign Q2 = Q2_temp;
  assign Q3 = Q3_temp;
  assign NQ0 = NQ0_temp;
  assign NQ1 = NQ1_temp;
  assign NQ2 = NQ2_temp;
  assign NQ3 = NQ3_temp;
endmodule

module Semaforo_A (
  input Q0,
  input Q1,
  input Q2,
  input Q3,
  input NQ0,
  input NQ1,
  input NQ2,
  input NQ3,
  output RA,
  output AA,
  output VA
);
  assign RA = (Q1 | Q2);
  assign AA = (Q0 | (NQ1 & NQ2 & Q3));
  assign VA = (NQ3 & NQ2 & NQ1 & NQ0);
endmodule

module Semaforo_B (
  input Q0,
  input Q1,
  input Q2,
  input Q3,
  input NQ0,
  input NQ1,
  input NQ2,
  input NQ3,
  output RB,
  output AB,
  output VB
);
  assign RB = ((NQ3 & Q2 & Q1) | Q0 | (NQ2 & NQ3) | (NQ2 & Q1));
  assign AB = ((Q2 & Q3) | (Q3 & NQ0 & NQ1));
  assign VB = (Q2 & NQ3 & NQ1);
endmodule

module Semaforo_C (
  input Q0,
  input Q1,
  input Q2,
  input Q3,
  input NQ0,
  input NQ1,
  input NQ2,
  input NQ3,
  output RC,
  output AC,
  output VC
);
  assign VC = (NQ2 & NQ3 & Q1);
  assign AC = ((Q2 & Q3 & NQ1) | (Q3 & NQ2 & Q0) | (Q3 & NQ2 & Q1));
  assign RC = ((NQ2 & NQ1 & NQ0) | (NQ3 & Q2) | (Q1 & Q2) | (NQ3 & NQ1 & Q0));
endmodule

module Semaforo_D (
  input Q0,
  input Q1,
  input Q2,
  input Q3,
  input NQ0,
  input NQ1,
  input NQ2,
  input NQ3,
  output RD,
  output AD,
  output VD
);
  assign RD = ((NQ1 & Q3) | (NQ3 & NQ2 & NQ0) | (NQ0 & NQ1));
  assign AD = ((Q0 & NQ2 & NQ3) | (Q3 & Q1));
  assign VD = (Q2 & NQ3 & Q1);
endmodule

module top (
  input App,
  input Ap,
  input Al,
  input All,
  input hclk,
  input Bpp,
  input Bp,
  input Bl,
  input Bll,
  input Cpp,
  input Cp,
  input Cl,
  input Cll,
  input Dpp,
  input Dp,
  input Dl,
  input Dll,
  output RB,
  output AB,
  output VB,
  output RA,
  output AA,
  output VA,
  output RD,
  output AD,
  output VD,
  output RC,
  output AC,
  output VC,
  output EA0,
  output EA1,
  output EB0,
  output EB1,
  output EC0,
  output EC1,
  output ED0,
  output ED1,
  output a,
  output b,
  output c,
  output d,
  output e,
  output f,
  output g
);
  wire [5:0] NA;
  wire [13:0] \7SA ;
  wire [5:0] ND;
  wire [13:0] \7SD ;
  wire [5:0] NB;
  wire [13:0] \7SB ;
  wire [5:0] NC;
  wire [13:0] \7SC ;
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire Q0;
  wire Q1;
  wire Q2;
  wire Q3;
  wire NQ0;
  wire NQ1;
  wire NQ2;
  wire NQ3;


divFreq clk1(
.CLK_IN(hclk), 
.CLK_OUT( clk_count )
);

divFreqMUX clk2(
.CLK_IN(hclk), 
.CLK_OUT( clkMUX )
);





  Contador Contador_i0 (
    .clk_count( clk_count ),
    .\++ ( App ),
    .\+ ( Ap ),
    .\- ( Al ),
    .\-_- ( All ),
    .Num( NA ),
    .\NUM-7S ( \7SA  )
  );
  Contador Contador_i1 (
    .clk_count( clk_count ),
    .\++ ( Dpp ),
    .\+ ( Dp ),
    .\- ( Dl ),
    .\-_- ( Dll ),
    .Num( ND ),
    .\NUM-7S ( \7SD  )
  );
  Contador Contador_i2 (
    .clk_count( clk_count ),
    .\++ ( Bpp ),
    .\+ ( Bp ),
    .\- ( Bl ),
    .\-_- ( Bll ),
    .Num( NB ),
    .\NUM-7S ( \7SB  )
  );
  Contador Contador_i3 (
    .clk_count( clk_count ),
    .\++ ( Cpp ),
    .\+ ( Cp ),
    .\- ( Cl ),
    .\-_- ( Cll ),
    .Num( NC ),
    .\NUM-7S ( \7SC  )
  );
  \10_2  \10_2_i4 (
    .clk_FSM( clk_count ),
    .\10-2 ( s4 )
  );
  Comparador Comparador_i5 (
    .NA( NA ),
    .NB( NB ),
    .NC( NC ),
    .ND( ND ),
    .TA( s0 ),
    .TB( s1 ),
    .TC( s2 ),
    .TD( s3 )
  );
  MUX MUX_i6 (
    .clk_MUX( clkMUX ),
    .\7SA ( \7SA  ),
    .\7SB ( \7SB  ),
    .\7SC ( \7SC  ),
    .\7SD ( \7SD  ),
    .a( a ),
    .b( b ),
    .c( c ),
    .d( d ),
    .e( e ),
    .f( f ),
    .g( g ),
    .EA0( EA0 ),
    .EA1( EA1 ),
    .EB0( EB0 ),
    .EB1( EB1 ),
    .EC0( EC0 ),
    .EC1( EC1 ),
    .ED0( ED0 ),
    .ED1( ED1 )
  );
  FSM FSM_i7 (
    .clk_FF( s4 ),
    .TA( s0 ),
    .TB( s1 ),
    .TC( s2 ),
    .TD( s3 ),
    .Q0( Q0 ),
    .Q1( Q1 ),
    .Q2( Q2 ),
    .Q3( Q3 ),
    .NQ0( NQ0 ),
    .NQ1( NQ1 ),
    .NQ2( NQ2 ),
    .NQ3( NQ3 )
  );
  Semaforo_A Semaforo_A_i8 (
    .Q0( Q0 ),
    .Q1( Q1 ),
    .Q2( Q2 ),
    .Q3( Q3 ),
    .NQ0( NQ0 ),
    .NQ1( NQ1 ),
    .NQ2( NQ2 ),
    .NQ3( NQ3 ),
    .RA( RA ),
    .AA( AA ),
    .VA( VA )
  );
  Semaforo_B Semaforo_B_i9 (
    .Q0( Q0 ),
    .Q1( Q1 ),
    .Q2( Q2 ),
    .Q3( Q3 ),
    .NQ0( NQ0 ),
    .NQ1( NQ1 ),
    .NQ2( NQ2 ),
    .NQ3( NQ3 ),
    .RB( RB ),
    .AB( AB ),
    .VB( VB )
  );
  Semaforo_C Semaforo_C_i10 (
    .Q0( Q0 ),
    .Q1( Q1 ),
    .Q2( Q2 ),
    .Q3( Q3 ),
    .NQ0( NQ0 ),
    .NQ1( NQ1 ),
    .NQ2( NQ2 ),
    .NQ3( NQ3 ),
    .RC( RC ),
    .AC( AC ),
    .VC( VC )
  );
  Semaforo_D Semaforo_D_i11 (
    .Q0( Q0 ),
    .Q1( Q1 ),
    .Q2( Q2 ),
    .Q3( Q3 ),
    .NQ0( NQ0 ),
    .NQ1( NQ1 ),
    .NQ2( NQ2 ),
    .NQ3( NQ3 ),
    .RD( RD ),
    .AD( AD ),
    .VD( VD )
  );
endmodule
